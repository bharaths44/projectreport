\chapter{Implementation}

\section{System Overview}

The ASTRO platform has been implemented using a modern technology stack that ensures scalability, performance, and cross-platform compatibility. The implementation follows a client-server architecture with clear separation of concerns:

\begin{itemize}
    \item \textbf{Backend}: Developed using FastAPI, a modern, high-performance Python web framework
    \item \textbf{Frontend}: Built with Flutter to provide a seamless cross-platform experience for both mobile and web clients
    \item \textbf{Database}: Utilizes Firebase Firestore for flexible, scalable NoSQL document storage with real-time capabilities
    \item \textbf{Machine Learning Pipeline}: Implemented in Python using libraries such as NeuralProphet, scikit-learn, and pandas
\end{itemize}
\section{Backend Implementation}

\subsection{FastAPI Framework}

The backend system is implemented using FastAPI, a modern Python web framework designed for building high-performance APIs. FastAPI was chosen for several key advantages:

\begin{itemize}
    \item \textbf{Performance}: Built on Starlette and Pydantic, FastAPI offers near-native performance comparable to Node.js and Go
    \item \textbf{Type Checking}: Utilizes Python type hints for automatic validation and documentation
    \item \textbf{Asynchronous Support}: Native support for async/await patterns to handle concurrent requests efficiently
    \item \textbf{API Documentation}: Automatic generation of OpenAPI and Swagger UI documentation
    \item \textbf{Dependency Injection}: Built-in system for managing dependencies and services
\end{itemize}

\subsection{Database Schema}

The database schema is implemented using Firebase Firestore, a NoSQL document database that provides real-time synchronization and offline capabilities. The system uses Pydantic models for data validation and serialization:

Firestore's flexible document structure enables easy storage and retrieval of complex nested data, which is particularly beneficial for order items and shipping addresses. The system leverages Firestore's querying capabilities for efficient data filtering and real-time updates.
\subsection{API Endpoints}

The API is organized into several functional modules, each handling specific aspects of the platform:

Key API endpoints include:

\begin{enumerate}
    \item \textbf{Core Endpoints}:
          \begin{itemize}
              \item \texttt{GET /}: Root endpoint
              \item \texttt{GET /info}: System information
          \end{itemize}

    \item \textbf{Vendor Operations}:
          \begin{itemize}
              \item \texttt{GET /vendor/suppliers}: Get list of suppliers
              \item \texttt{GET /vendor/products/\{supplier\_id\}}: Get products from a supplier
              \item \texttt{POST /vendor/orders}: Place a new order
              \item \texttt{POST /vendor/instant\_order}: Place an order for immediate fulfillment
          \end{itemize}

    \item \textbf{Product Management}:
          \begin{itemize}
              \item \texttt{POST /supplier/\{supplier\_id\}/add\_product}: Add a new product
              \item \texttt{PUT /supplier/update\_product/\{product\_id\}}: Update product details
              \item \texttt{DELETE /supplier/delete\_product/\{product\_id\}}: Remove a product
              \item \texttt{GET /supplier/get\_products/\{supplier\_id\}}: Get supplier's products
          \end{itemize}

    \item \textbf{Order Aggregation}:
          \begin{itemize}
              \item \texttt{POST /supplier/aggregate\_orders}: Process orders for aggregation
              \item \texttt{POST /supplier/update\_instant\_order\_status}: Update status of instant orders
          \end{itemize}

    \item \textbf{Route Optimization}:
          \begin{itemize}
              \item \texttt{GET /route-optimization/\{aggregation\_id\}}: Generate optimal delivery route
          \end{itemize}

    \item \textbf{Demand Forecasting}:
          \begin{itemize}
              \item \texttt{GET /demand-forecast/\{product\_id\}}: Get demand forecast for a product
          \end{itemize}
\end{enumerate}

Each endpoint is implemented with appropriate request validation, error handling, and business logic to ensure robust operation of the platform.

\section{Frontend Implementation}

\subsection{React and TypeScript Application}

The frontend client application is implemented using React with TypeScript and Tailwind CSS, providing a robust and modern web development stack. Key advantages of using this technology combination include:

\begin{itemize}
    \item \textbf{Type Safety}: TypeScript adds static typing to JavaScript, enabling early error detection and improved developer experience
    \item \textbf{Component-Based Architecture}: React's modular component system promotes reusability and maintainable code
    \item \textbf{Utility-First CSS}: Tailwind's approach allows for rapid UI development without leaving HTML
    \item \textbf{Responsive Design}: Tailwind's responsive utilities make building adaptive interfaces straightforward
    \item \textbf{Performance Optimizations}: React's virtual DOM and Tailwind's PurgeCSS integration ensure efficient applications
\end{itemize}

\subsection{Application Architecture}

The React application follows a modern architecture pattern leveraging React hooks and context for state management:

\begin{itemize}
    \item \textbf{Custom Hooks}: Encapsulating business logic and state management
    \item \textbf{Context API}: For global state management and theme configuration
    \item \textbf{TypeScript Interfaces}: Strict typing of props, state, and API responses
    \item \textbf{Component Composition}: Building complex UIs from simpler, reusable components
    \item \textbf{Tailwind Configuration}: Extended theme with custom colors and component classes
\end{itemize}

\subsection{Key UI Components}

The application includes several key screens and components:

\begin{enumerate}
    \item \textbf{Dashboard}: Provides an overview of key metrics and recent activities
    \item \textbf{Inventory Management}: Allows vendors to track their inventory levels
    \item \textbf{Order Creation}: Interface for creating new orders
    \item \textbf{Forecast Visualization}: Displays demand forecasts with interactive charts using Recharts
    \item \textbf{Cluster Notification}: Alerts vendors about potential order aggregation opportunities
    \item \textbf{Order Tracking}: Real-time tracking of order status and delivery
\end{enumerate}

\section{Integration and Communication}

\subsection{API Integration}

The React application communicates with the FastAPI backend through RESTful API calls, implemented using Axios with React Query:

\begin{itemize}
    \item \textbf{React Query}: For data fetching, caching, and synchronization
    \item \textbf{Axios Interceptors}: Handling authentication and request/response formatting
    \item \textbf{TypeScript Types}: Ensuring type safety in API requests and responses
    \item \textbf{Custom Hooks}: Wrapping API calls in reusable React hooks for component consumption
\end{itemize}

\subsection{Real-time Notifications}

The system implements real-time notifications using Firebase Cloud Messaging (FCM) to deliver timely alerts to vendors:

\begin{itemize}
    \item \textbf{Firebase Cloud Messaging}: Cross-platform notification delivery with support for both foreground and background messaging
    \item \textbf{React Firebase Hooks}: Integration with React application state to handle incoming messages
    \item \textbf{Notification Permission Management}: Streamlined handling of browser notification permissions
    \item \textbf{Tailwind Notification Components}: Customized UI elements for displaying in-app notifications with consistent styling
    \item \textbf{Service Worker Registration}: Background notification delivery even when the application is closed
    \item \textbf{Topic-based Subscriptions}: Allowing vendors to subscribe to relevant notification categories (orders, inventory alerts, etc.)
\end{itemize}

The FCM implementation ensures reliable delivery of critical notifications across devices, with customizable delivery options for different notification priorities. For high-priority notifications, the system leverages FCM's capability to wake devices, ensuring time-sensitive information reaches vendors immediately.
\section{Security Implementation}
\subsection{Authentication and Authorization}

The system leverages Firebase Authentication for secure user management:

The authentication flow works as follows:

\begin{enumerate}
    \item The user authenticates with Firebase Authentication in the Flutter app
    \item Firebase returns an ID token which is stored securely on the device
    \item This token is included in API requests in the Authorization header
    \item The backend verifies the token with Firebase Admin SDK
    \item Upon successful verification, the system retrieves the user profile from Firestore
\end{enumerate}

Role-based authorization is implemented using Firestore's security rules and custom claims in the Firebase ID token, allowing for granular access control between vendors and suppliers.

\subsection{Data Encryption}

Sensitive data is encrypted both at rest and in transit:

\begin{itemize}
    \item HTTPS for all API communications
    \item Firebase's built-in encryption for database at rest
    \item Secure storage for authentication tokens on client devices using Flutter Secure Storage
    \item API keys and secrets managed through environment variables and Firebase Remote Config
\end{itemize}

\section{Summary}

The implementation of the ASTRO platform leverages modern technologies and architecture patterns to deliver a robust, scalable, and performant solution. By utilizing FastAPI for the backend and Flutter for the frontend, the system achieves a balance between development efficiency and runtime performance. The modular design ensures that each component order aggregation, logistics optimization and demand forecasting can evolve independently while maintaining integration with the broader system.

The implementation demonstrates how complex algorithms and advanced machine learning techniques can be effectively deployed in a production environment, providing tangible benefits to vendors through improved demand forecasting, efficient order aggregation, and optimized logistics.